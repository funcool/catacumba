= Catacumba - Web toolkit for Clojure.
Andrey Antukh, <niwi@niwi.nz>
v0.11.2
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Introduction

_Catacumba_ is an asynchronous or non-blocking web toolkit for Clojure built on top
of ratpack and netty drawing inspiration from ring, pedestal and ratpack.

[NOTE]
====
*Project Maturity*: +
Since _catacumba_ is a young project there may be some API breakage. +

*Rationale*: +
You can read the rationale behind this project <<rationale,here>>.
====


[[quickstart]]
== Quick Start

This section intends to explain how to get _catacumba_ up and running.


=== Install

The simplest way to use _catacumba_ in a clojure project is by including it in the
dependency vector on your *_project.clj_* file:

[source,clojure]
----
[funcool/catacumba "0.11.2"]
----

NOTE: _Catacumba_ will only run with *JDK8* and *Clojure >= 1.7*.


=== Handlers

The handler consists of a function that accepts a "context" as it's first parameter
and returns something renderable. Let's see an example:

[source, clojure]
----
(defn example-handler
  [context]
  "Hello World")
----

It looks very similar to ring hand with two main differences:

* instead of request ir receives a *context* that works like request but with
  more responsibilities (explained in other sections).
* returns a string instead of a hash-map (it is also allowed but is not mandatory,
  also explained later).


[[quick-start-routing]]
=== Routing

Now knowing how we can define handlers, the next step is define a route (http
endpoint) for our handler. That can be done with `routes` function:

[source, clojure]
----
(require '[catacumba.core :as ct])

(def app
  (ct/routes [[:all "" example-handler]
              [:get "foobar" example-handler]]))
----

The `routes` function receives a vector of ordered entry points for our handlers,
and in this example we have defined two routes for the same handler (just for
demonstration purposes):

The first entry defines a `/` route for all kind of requests and the second entry
defines a `/foobar` route only for `GET` requests for the same handler.

You can read a complete documentation about catacumba's routing <<routing,here>>.


=== Run the server

For run the previously defined handler, just use the `run-server` function:

[source, clojure]
----
(ct/run-server app {:port 3030})
----

TIP: The `run-server` function doesn't block so you can execute it in a repl without problems.

You can read more about all available options that you can pass to `run-server`
function <<launching-the-server,here>>.


=== Put all together

This is what the complete source code of the example looks like:

[source, clojure]
----
(ns exampleapp.core
  (:require [catacumba.core :as ct])
  (:gen-class))

(defn example-handler
  [context]
  "Hello World")

(def app
  (ct/routes [[:all "" example-handler]
              [:get "foobar" example-handler]]))

(defn -main
  [& args]
  (ct/run-server app {:port 3030}))
----

_Catacumba_ also comes with a little collection of <<examples,Examples>> that may
help you setup your first project.


== User Guide

This section intends explain all the different parts of _catacumba_ and how they work
together.


=== Handlers

Is the fundamental building block in the _catacumba_ toolkit and has two main types:

- *Ending*: Handlers that process a request and return a response (usually named
  controller in other web frameworks or toolkits).
- *Middle*: Handlers that does some logic but does not return any response (
  delegating that task to other handler) (usually named as middleware or decorator).

The both handler types are defined in term of functions and looks identically, the
principal change is the responsibility. Let see an example:

.An *ending* handler example.
[source, clojure]
----
(defn sample-ending-handler
  [context]
  "Hello World")
----

.An *middle* handler example.
[source, clojure]
----
(defn sample-middle-handler
  [context]
  (println "hello world")
  (ct/delegate))
----


==== The ending handlers

As you have seen, the examples until now are always returning a simple string that
in fact is not very useful in real-world use cases. The great news here is that
return values are handled using open polymorphic abstractions that clojure offers:
protocols.

This means that you can return anything that catacumbla already has implementation
for it or anything that yourself have implemented. Let see some examples:

.Handler example that returns ring style response.
[source, clojure]
----
(defn some-handler
  [context]
  {:status 200
   :headers {}
   :body "Hello World"})
----

.Handler example that returns catacumba's builtin response type.
[source, clojure]
----
(require '[catacumba.http :as http])

(defn some-handler
  [context]
  (http/ok "Hello World"))
----

But this is not the end, if you want to know all the different kind of handlers
and its return types, please take a look on <<handler-types,Handler types>> section.


==== The middle handlers

The catacumba toolkit in request/response handling perspective behaves like a
pipeline of handlers (when only one handler is attached it will be a pipeline of
one unique element).

As you have observed in the previous example, the *middle* handler instead of
returning a response, returns a result an opaque type that indicates to catacumba
that this handler is not of *ending* type and forces to catacumba take the next
handler from the pipeline and execute it. And so until *ending* handler is found
and response is returned.

There are nothing especial, the opaque object that `delegate` function returns
just implement appropriate protocol and if you don't like the default behavior,
you are free to implement your own.

This is a little introduction to the delegation process and how the *middle*
handlers participates on it. For in depth understanding and how you can use it
in your application, please read the <<handler-delegation, handler delegation>>
section.


=== Context

The second thing most important in the catacumba is the *context*. It can
be considered a central part of both: IO and the control flow (will be
explained in advanced section).

In other words it can be considered as a combination of request and response.


==== Response

In the previous examples, we've seen how the return value is handled, but behind
the scenes the context is responsible for interacting with both the request and
response.

Let's see the same example but interacting directly with the context using low-level
mutable api:

[source, clojure]
----
(defn myhandler
  [context]
  (ct/set-status! context 200)
  (ct/set-headers! context {:content-type "text/plain"})
  (ct/send! context "hello world"))
----

The return value handler is really just a helper for people coming from ring.
Internally, the context is the main player in IO operations.


==== Request

The most important thing here is that the context in a user end acts like a request
object and allows access to the most used part of the request such as the `:body`,
`:method`, `:query`, `:path`, `:headers` and `:cookies`. All them are accessible
with keyword lookups:

[source, clojure]
----
(:body request)
;; => <TypedData>
----

The `TypedData` is a ratpack
link:http://ratpack.io/manual/current/api/ratpack/http/TypedData.html[internal type]
that represents the http request body.

That object exposes through Java interop methods to access the content type and the
raw data of the request body. For convenience, it implements the `clojure.java.io`
protocols for make it compatible with Clojure's native facilities for reading data.

A good demonstration of this is using the clojure `slurp` function. It uses
`clojure.java.io` abstractions behind the scenes and serves as helper for reading a
resource as a string:

[source, clojure]
----
(def myechohandler
  [context]
  (let [^String body (slurp (:body context))]
    (http/ok body)))
----

The `slurp` function uses the abstractions defined on the `clojure.java.io` namespace
for read the content of the provided resource as string and return it.

Furthermore, _catacumba_ offers a more flexible way to parsing body data based on the
incoming content type, but it is explained with more details in the
<<body-parsing,body parsing section>> of this document.

Like the http request body, the http headers are available through the `:headers` key
entry. In order to extract some header, just perform the appropriate lookup:

[source, clojure]
----
(get-in context [:headers :origin])
;; => "https://github.com"
----

If a header has multiple values, the value will be a vector.

Here a complete reference of the available attributes of the context object:

[cols="1,1,3,2", options="header"]
|===
|Key
|Type
|Description
|Example

|`:body`
|link:http://ratpack.io/manual/current/api/ratpack/http/TypedData.html[`TypedData`]
|A object that represents a request body.
|

|`:method`
| `Keyword`
| A request method.
| `:head`, `:trace`, `:get`, `:options`, `:put`, `:post`, `:patch` and `:delete`

|`:query`
|`String`
|A raw string representation of the uri querystring.
| `"foo=bar&baz=1"`

|`:path`
|`String`
|A raw string representation of the uri path.
|`/auth/client`

|`:headers`
|`PersistentMap`
|A optionally multi value hash map of the request headers.
|`{:host "funcool.org" :pragma "no-cache" ...}`

|`:cookies`
|`PersistentMap`
|A optionally multivalue hash map of request cookies (explained in details in its own section).
|

|`:query-params`
|`PersistentMap`
|A optionally multivalue hash map of the parsed `:query` string.
|`{:foo "bar" :bar 1}`

|===

The `context` also contains other keys but them will explain in its corresponding section.


=== Cookies

The cookies CRUD operations works very similar to the headers one. You can access
to the request cookies through direct keyword lookup on context object:

[source, clojure]
----
(get-in context [:cookies :somecookie])
;; => {:value "foo" :path "/" ...}
----

The cookies map is almost identical to the one that you can find in ring, and has
the following possible properties:

* `:domain` - restrict the cookie to a specific domain
* `:path` - restrict the cookie to a specific path
* `:secure` - restrict the cookie to HTTPS URLs if true
* `:http-only` - restrict the cookie to HTTP if true
                 (not accessible via e.g. JavaScript)
* `:max-age` - the number of seconds until the cookie expires

For set cookies, you should use the `set-cookies!` function as you can see in the
following example:

[source, clojure]
----
(ct/set-cookies! context {:cookiename {:value "foobar" :max-age 3600}})
----

[[routing]]
=== Routing

In contrast to ring, _catacumba_ is a toolkit for web development and offers builtin
support for advanced routing that allows handlers chaining, partitioning, error
handling, among other features.

NOTE: _Catacumba_ has a polymorphic and extensible way to setup handlers, and
routing is one of multiple possible implementations. Is completely optional and you
can use any other routing library if you want.


==== Basic syntax

The routes in _catacumba_ are defined using clojure data structures: vectors and
keywords. Let's see a little example of the aspect in a complete example:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:get "users" users-handler]]]))
----

The order of statements is very important because the routing in _catacumba_ is a
simple chain or pipeline. Each handler has the ability to delegate the request
handling to the next handler in the pipeline.

This is a complete list of route directives that you can use a part of `:get`:
`:any` (matches all routes, often used for add chain handlers), `:post`, `:put`,
`:patch` and `:delete`.


==== Dispatch by method

In some circumstances you may want have different handlers depending on the HTTP
method used for one concrete endpoint. You can do it in the following way:

[source, clojure]
----
(ct/routes [[:prefix "api/users"
             [:get list-users-handler]
             [:post create-users-handler]]])
----

This also can be done in this an other way:


[source, clojure]
----
(ct/routes [[:get "api/users" list-users-handler]
            [:post "api/users" create-users-handler]])
----

But is considered not idiomatic and the first example should be considered
the right way to do it.

[NOTE]
====
Before, there was an other way to setup by method using the `:by-method`
routing directive. It is now deprecated and will be removed in the next
versions.
====


==== Routing params

_catacumba_'s routing also allows to capture URL values encoded in the URL or as URL
parameters using special symbols. For example, the path string "foo/:val" will
match paths such as "foo/bar", "foo/123".  The matched parameters are automatically
populated to the context under the `:route-params` key:

[source, clojure]
----
(def article-detail
  [context]
  (let [id (get-in context [:route-params :id])]
    (http/ok (str "You have requested article with id=" id))))

(def app
  (ct/routes [[:get "articles/:id" article-detail]]))
----

Additionally to the basic token for representing URL parameters, _catacumba_ also
allows the use of regular expressions for delimiting the input or marking a URL
token optional.

See the following table for all supported URL tokens:

.Supported url matching tokens
[options="header", cols="2,3,3,2"]
|===========================================================================
| Path Type | Syntax | Route example | Matching url example
| Literal | `foo` | `[:get "foo" handler]` | `/foo`
| Mandatory | `:«token-name»` | `[:get "foo/:param" handler]` | `/foo/bar`
| Optional | `:«token-name»?` | `[:get "foo/:param?" handler]` | `/foo` and `/foo/bar`
| Mandatory & Regex | `:«token-name»:«regex»` | `[:get "foo/:id:\d+" handler]` | `/foo/2`
| Optional & Regex | `:«token-name»?:«regex»` | `[:get "foo/:id?:\d+" handler]` | `/foo/2` and `/foo`
|===========================================================================


==== Routing chain

The chaining of handlers can be done in two different ways:

- *inline*: providing more that one handler for concrete http method.
- *multiple routes*: providing a "match all" handler at the start of prefix.

Chaining handlers inline follows this pattern:

[source, clojure]
----
(ct/routes [[:get "users" permission-check-handler get-users-handler]])
----

Additionally, you can setup "match all" handlers at the start of a routing
definition and use them as interceptors:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:any authentication-handler]
               [:get "users" users-handler]]]))
----

For a better understanding of how the handler delegation chain works, see the
*Handlers delegation* section in advanced guide chapter.


==== Error handling

The _catacumba_ router chain allows to setup user defined error handling functions.
This requires a very simple setup, you only have to add another route entry with
using `:error` route directive:

[source, clojure]
----
(def routes
  (ct/routes [[:error my-error-handler]
              [:get "users" users-handler]]))
----

With the previous code we have set up a global error handler, applying to all
routes in the chain. But there is also the possibility to set different error
handlers for different prefixes:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:error my-error-handler-for-this-prefix]
               [:any authentication-handler]
               [:get "users" users-handler]
               [:put "users" check-permissions-handler update-users-hander]]
              [:prefix "admin"
               [:error my-error-handler-for-this-other-prefix]
               [:get "dashboard" my-dashboard-handler]]]))
----

The error handler signature is very similar to standard HTTP handler signature,
with the difference being that it receives the throwable instance as an additional
parameter:

[source, clojure]
----
(defn my-error-handler
  [context error]
  (http/internal-server-error (.getMessage error)))
----


==== Serving static files

_Catacumba_ also comes with the ability to serve static files. This is can be done
using `:assets` routing directive. Here an example:

[source, clojure]
----
(ct/routes [[:assets "assets" {:dir "public/assets"}]])
----

Additionally, it has support for specify a index file, that will be returned if no
file is requested. This is very useful for SPA (single page applications):

[source, clojure]
----
(ct/routes [[:assets "assets" {:dir "public/assets"
                               :indexes ["index.html"]}]])
----

So, if you make a http request to `/assets/` the `index.html` will be automatically
returned.

NOTE: the assets are resolved using the `:basedir` parameter of the server
constructor; for more details see the <<launching-the-server,Launching the server>>
section.

[[advanced-topics]]
== Advanced topics

[[handler-delegation]]
=== Handler delegation

A part of the obvious (and previously explained) responsibility of the `context`
object in catacubla, it has some others responsibilities. Here just a summary of
them:

Here a small summary of the context responsibilities besides the obvious one
explained in previous sections (IO handling):

* Provide direct access to the request and response objects.
* Access to the contextual objects (called registry).
* Flow control in handler chaining.
* Convenience helpers for common handlers operation.

In a catacumba design (inherited from ratpack), a handler is a unit of work in
an asynchronous handler pipeline and the context is a execution controller and
local storage for the current request state.

In other words it can be explained as "flow control" in the chain of handlers.

The request process is an asynchronous pipeline of handlers that can be
composed in different ways (as we previously seen in other parts of the
documentation). So the each handler in the pipeline has the ability to do some
work and delegate the rest of processing to next handler in the chain.

This approach allows you build different kind of modular and completely decoupled
handlers and compose them into a pipeline to work together.

The delegation response can be done with `delegate` function. Let see a simple
example:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate)

(defn handler2
  [context]
  (http/ok "hello world"))

(def router
  (ct/routes [[:get "foo" handler1 handler2]]))
----

In this example, when the request arrives at `handler1`, it delegates the execution
to the next handler in the chain. It do not need to know about next handler, it
just delegates to the routing chain to find a next handler or raise a corresponding
error.

In addition to the simple handler delegation, _catacumba_ offers a simple way to pass
context data to the next handler in the chain. It can be done by passing an
additional parameter to the `delegate` function:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate {:message "foobar"}))

(defn handler2
  [context]
  (let [message (:message context)]
    (http/ok message)))
----

In the example above, the second handler prints the message found in the context.



=== Modular components

_Catacumba_ is build from its ground with optional support for the
`stuartsierra/component` library, and exposes a `catacumba-server` component with
an API for adding routes and handlers from other components.

Let see a little example on how it can be used:

[source, clojure]
----
(ns yourapp.system
  (:require [com.stuartsierra.component :as component]
            [catacumba.components :refer (catacumba-server assoc-routes!)]))

;; Define your web application component, it will be responsible to setup
;; the routes to the catacumba-server component of your handlers

(defrecord WebApp [server]
  component/Lifecycle
  (start [this]
    (let [routes [[:get "foo" some-handler]
                  [:get "bar" other-handler]]]
      (assoc-routes! server ::web routes)))

  (stop [this]
    ;; noop
    ))

;; Define a simple constructor for your web application component
(defn webapp []
  (->WebApp nil))

;; Define the system with two main components: catacumba-server and webapp
;; and explicitly specify the dependency of catacumba-server for webapp/

(defn application-system
  "The application system constructor."
  []
  (-> (component/system-map
       :catacumba (catacumba-server {:port 5050})
       :app (webapp))
      (component/system-using
       {:app {:server :catacumba}})))

;; Just define an entry point for the application.

(defn -main
  "The main entry point to your application."
  [& args]
  (component/start (application-system)))
----

Be aware that each call to the `assoc-routes!` function will cause the server
to reload. In the majority of circumstances this is completely irrelevant
because it is done at application bootstrap time.

To understand it better, _catacumba_ comes with an <<sse-component-example,example>>
that builds a multiuser chat using "Server-Sent events" and component, so you can
experiment with real code. See the <<examples,examples>> section for it.

[[launching-the-server]]
=== Launching the server

==== Getting Started

As you can see in the quick start section, the main entry point for start the
server is the `run-server` function that receives a handler chain and a map
with options.

[source, clojure]
----
(require '[catacumba.core :as ct])

;; handler definition goes here

(ct/run-server #'my-handler {:port 4040 :debug true})
----


==== Configuration Options

Here a complete reference of the currently supported options that can be passed
to the `run-server` function:

[options="header", cols="^1,^1,3"]
|===========================================================================
| Keyword   | Default | Description
| `:port`   | `5050` | The port to listen on.
| `:threads` | (num of cores * 2) | The number of threads for handler requests.
| `:debug` | `false` | Start in development mode.
| `:setup` | `nil`    | A callback for configuration step (low level ratpack access).
| `:basedir` | `nil` | The application base directory, used mainly for resolving relative paths and assets.
| `:keystore-path` | `nil` | A relative path in the classpath to the ssl keystore.
| `:keystore-secret` | `nil` | A secret for the ssl key store
| `:decorators` | `nil` | A vector of handlers to attach at the start of the pipeline
|===========================================================================

All supported options of this function, can be overwritten at JVM startup, using
environment variables or system properties. This allows to customize the
server without modifying source code and exists for convenience to make easy
customizations in deployments.

For example, you can change the default port on JVM startup using the
`CATACUMBA_PORT` environment variable or `catacumba.port` system property:

.Example using enviroment variables
[source, bash]
----
export CATACUMBA_PORT=8000
export CATACUMBA_BASEDIR=`pwd`
java -jar yourjarhere.jar
----

.Example using enviroment variables
[source, bash]
----
java -Dcatacumba.port=8000 -Dcatacumba.debug=true -jar yourjarhere.jar
----

NOTE: if no `:basedir` is specified, catacumba will try to find a `.catacumba` file
in the classpath and will set a base dir to its directory.


==== SSL Configuration

_Catacumba_ server can be configured to use TLS (commonly known as SSL). The process
is pretty simple but it requires to have a proper key and certificate.

The first thing that you should care about is that _catacumba_ is built on jvm
that the default ssl certificate/key format used by nginx/apache it isn't compatible
but is very easy create a compatible file using the `openssl` command line.

Having a key and the certificate, just execute this command:

[source, bash]
----
openssl pkcs12 -export -in cert.pem -inkey key.pem -out store.p12
----

This process will ask you for a password that you must memorize and later
provide it to catacumba. Now, having the properly formated trusted store,
just pass some additional parameters on starting the server:


[source, clojure]
----
(ct/run-server #'my-handler {:port 4040
                             :keystore-secret "yoursecrethere"
                             :keystore-path "path/to/store.p12"})
----

NOTE: _catacumba_ at this moment does not has the "upgrade" approach so if
you setup ssl, only ssl connections will be accepted. So the most recommended
way to use ssl on your application is put catacumba behind nginx or haproxy
and make them handle the ssl.


[[handler-types]]
== Handler types

This section intends to explain the different kind of built in handler types and the
response types that comes out of the box with catacumba. This section is organized
on handler types as first level and possible supported return values as second
level.


=== Asynchronous

Asynchronous handlers are handlers that return a value in an asynchronous way using
one of the supported abstractions, such as core.async, reactive-streams and many
others (explained below).


==== Channel (core.async)

The `core.async` channel is one of the supported abstractions that comes with
_catacumba_ out of the box. It consists of a handler that returns a body as a
channel or response as a channel.

This is the aspect of async handler returning a core.async channel as a body:

[source, clojure]
----
(defn my-async-handler
  [context]
  (let [ch (chan)]
    (go
      (dotimes [i 10]
        (<! (timeout 500))
        (>! ch (str i "\n")))
      (close! ch))
    (http/ok ch)))
----

Do not worry about how much data you can send to the client, if you are using
channels in a right way (in a go block), you will send data to the client as fast
as the client can consume it. This technique is also called back pressure, and is
fully supported for chunked responses.

Additionally, you also can return a channel as the handler response. The main
difference is that in this case you should put a complete response into the channel:

[source, clojure]
----
(defn my-async-handler
  [context]
  (go
    (let [result (<! (do-some-async-task))]
      (http/ok (:data result)))))
----


==== CompletableFuture

Sometimes, you do not need send a chunked stream to the client, but your "business
logic" is defined in an asynchronous friendly API using promises (or something
similar). In this case, with _catacumba_ you can return a promise as a body or as a
response and the data will be sent to the client when the promise has been resolved
successfully.

The `CompletableFuture` is an other asynchronous primitive supported out of the box
by _catacumba_; so you can return it as body or as response.

For more pleasant usage of `CompletableFuture` in clojure, the
link:https://github.com/funcool/promesa[promesa library] is used. That library
provides a more clojure friendly api on top of JDK8 `CompletableFuture` and a great
sugar syntax for composing them thanks to the
link:https://github.com/funcool/cats[cats library].

.A example using the _promesa_ library api for create a `CompletableFuture` instance and return it as body.
[source, clojure]
----
(require '[promesa.core :as p])

(defn my-async-handler
  [context]
  (let [promise (p/promise "hello world")]
    (http/ok promise {:content-type "text/plain"})))
----

Like as usual, you can return an instance of `CompletableFuture` as response:

[source, clojure]
----
(require '[promesa.core :as p])

(defn my-async-handler
  [context]
  (p/promise (fn [resolve]
               (future
                 (Thread/sleep 100)
                 (resolve (http/ok "hello world"))))))
----

One of the advantages of using `CompletableFuture` abstraction with _promesa_ and
_cats_ libraries is that them both exposes additional sugar syntax that work with
promises in a more painless way.

Let see an example that takes the link:https://github.com/funcool/cats[cats]
`mlet` macro, composes few async computations in a very clojure familiar syntax:

[source, clojure]
----
(require '[promesa.core :as p])
(require '[cats.core :as m])

(defn my-async-handler
  [context]
  (m/mlet [tempvar (something-that-returns-promise context)
           result (do-something-with a)]
    (http/ok result)))
----

The result of `mlet` macro expression will be an instance of `CompletableFuture` that
eventually will be completed with the http response.


==== Manifold Deferred

The link:https://github.com/ztellman/manifold[manifold] library also offers a promise
like abstraction. The main advantage of using it is that is build for clojure and
is not restricted to JDK8.

.Example code that returns a body as manifold deferred.
[source, clojure]
----
(require '[manifold.deferred :as d])

(defn my-async-handler
  [context]
  (let [result (d/future
                 (Thread/sleep 1000)
                 "hello world")]
    (http/ok result {"content-type" "text/plain"})))
----

Like the previously explained abstractions, you also can return manifold deferreds
as handler response.


==== Manifold Streams

TODO


==== Reactive-Streams

The link:http://www.reactive-streams.org/[reactive-streams] support is inherited from
ratpack and like manifold streams it is only can be used for send the response body.

Here there isn't anything  new to explain, just build and/or compose your streams
and return them as http response body:

[source, clojure]
----
(require '[catacumba.stream :as stream])
(require '[cuerdas.core :as str])

(defn my-async-handler
  [context]
  (let [pub (->> (stream/publisher ["hello" " " "world"])
                 (stream/transform (map str/upper)))]
    (http/ok pub)))

;; It will return a chunked response to the client with "HELLO WORLD" string.
----

One of the best parts of the reactive-strams is that them comes with back pressure
support out of the box and it native support in ratpack makes them a great glue
abstraction for similar async primitives. In fact, the support for all stream like
primitives explained until now are implemented in terms of _reactive-streams_
publisher.


=== WebSockets

One of the main goals of _catacumba_ is come with builtin, full featured and
back pressure aware websockets support.

You can start a websocket connection in any _catacumba_ handler or route handler
using `websocket` function. It does not require any special handlers for dealing
with websockets. Let see an example:

[source, clojure]
----
(defn my-websocket-echo-handler
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(defn my-handler
  [context]
  (ct/websocket context my-websocket-echo-handler))

(def route
  (ct/routes [[:prefix "events"
               [:any my-handler]]]))
----


Additionally, _catacumba_ offers a way to set up a websocket handler directly,
without an additional step:

[source, clojure]
----
(defn echo-handler
  "This is my echo handler that serves as
  a websocket handler example."
  {:handler-type :catacumba/websocket}
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'echo-handler]]]))
----

As you can observe, the var metadata is used for properly choice the right adapter.

NOTE: Is very important pass a var reference to the router instead of the function
directly, because the metadata defined in the function is bound to the var and not
to the function.

Also, you can attach metadata inline, using the `with-meta` Clojure built-in
function:

[source, clojure]
----
(ct/routes [[:prefix "events"
             [:any (with-meta echo-handler
                     {:handler-type :catacumba/websocket})]]])
----

Clojure offers a lot of flexibility for working with metadata so you can set the
handler type in the way that you prefer.


=== SSE (Server-Sent Events)

WebSockets are cool because they allow bi-directional communication, but in some
circumstances we only need something unidirectional, for notifying the client about
some changes or any other events. For this purpose exists
link:https://developer.mozilla.org/en-US/docs/Server-sent_events[Server-Sent Events]
(SSE) and _catacumba_ also has support for it.

The handler for SSE does not differs much from websockets (that we have seen in the
previous section). The main difference is that server-sent events are unidirectional
and they only can send data in the server to client direction.

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  {:handler-type :catacumba/sse}
  [context out]
  (go-loop []
    (when-let [_ (>! out (str (java.time.Instant/now)))]
      (<! (timeout 1000))
      (recur))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'time-notification]]]))

----

In a similar way to websockets, you can start SSE in any place, such as a standard
_catacumba_ handler:

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  [context]
  (ct/sse context
          (fn [_ out]
            (go-loop []
              (when-let [_ (>! out (str (java.time.Instant/now)))]
                (<! (timeout 1000))
                (recur))))))

(def route
  (ct/routes [[:prefix "events"
               [:any time-notification]]]))

----

Let see some examples how you can send other parameters than simple data:

[source, clojure]
----
;; Send data
(>! out "data as string")
(>! out {:data "data as string"})

;; Send data with event name
(>! out {:data "data as string" :event "foobar"})

;; Set id
(>! out {:id "2"})
----

NOTE: The _catacumba_'s SSE support uses core.async channels, but if you are not
happy with core.async and want use something different (such as manifold streams),
you may want know that everything in _catacumba_ is implemented using abstractions
and to implement your own SSE type of handler that uses manifold streams is very
easy.


=== Ring (Compatibility layer)

Although ring support is not first citizen in _catacumba_, the current design of
it allows to create an handler adapter that follows the ring specification. This
is a great example of extensibility of _catacumba_.

Let see how it can be done:

[source, clojure]
----
(defn myringhandler
  "My example ring handler."
  {:handler-type :catacumba/ring}
  [request]
  {:status 200
   :body "hello world"})

;; As standalone handler
(ct/run-server #'myringhandler)

;; Or in a _catacumba_ routing chain
(-> (ct/routes [[:get #'myringhandler]])
    (ct/run-server))
----

Ring handlers can be set as standalone handlers (mainly for using them with
compojure and all related middlewares) or in a _catacumba_'s routing chain.


=== CPS (Continuation-passing style)

Is a low level handler type that works in a cps style (in other words, they works
with callbacks). This is not general purpose handler type but you maybe found it
useful for integrate catacumba with other scenarios that it is not initially
designed to work.

This is the aspect ot the cps style handler:

[source, clojure]
----
(defn my-cps-handler
  "Some usefull docstring."
  {:handler-type :catacumba/cps}
  [context callback]
  (future
    (Thread/sleep 1000)
    (callback "hello world")))
----


== Built-in Handlers

This section will cover different kind of built-in additional handlers to make the
experience of using _catacumba_ more pleasant.


[[body-parsing]]
=== Body parsing

_Catacumba_ comes with builtin support for conditional body parsing depending on the
incoming content type. It consists of a routing chain that adds the `:data` entry in
the context with the parsed data or `nil` in case of an incoming content type does
not have an attached parser implementation.

In order to use it you should prepending the `body-params` handler to your route
chain:

[source, clojure]
----
(require '[catacumba.handlers.parse :as parse])

(defn example-handler
  [context]
  (let [body (:data context)]
    (println "Received data:" body)
    (http/no-content)))

(def app
  (ct/routes [[:any (parse/body-params)]
              [:any example-handler]]))

;; ...
----

By default, the `application/x-www-form-urlencoded`, `multipart/form-data`,
`application/json`, `application/transit+json` and `application/transit+msgpack`
parsers come out of the box. The link:https://github.com/dakrone/cheshire[cheshire]
json parser is used for parsing the body with the `application/json` content type.

The body parsing is a open system, implemented using clojure's polymorphism facilities
such as multimethods. If you want add additional parser, just add an additional
implementation to the parse multimethod with your content-type as dispatch tag.

[source, clojure]
----
(require '[catacumba.handlers.parse :as parse])
(import 'ratpack.http.TypedData
        'ratpack.handling.Context)

(defmethod parse/parse-body :application/xml
  [^Context ctx ^TypedData body]
  ;; your parsing logic here
  )
----


=== Autoreload

The autoreload handler consist in a very simple concept: reload all modified
namespaces on each request. If you are familiar with the ring reload middleware,
this one works in almost identical way.

For use it, just attach it to your routing chain:

[source, clojure]
----
(require '[catacumba.handlers.misc :as misc])

(def app
  (ct/routes [[:any (misc/autoreloader)]
              [:get "foo" #'somens/your-handler]
              [:get "bar" #'somens/other-handler]
              [:post ...]]))
----

You can see a working example in the <<website-example,Website example>> code.

[TIP]
====
The auto-reloading can only work if you pass var references to the router
definition instead resolved values. In same way as the previous example.
====


=== Sessions

==== Getting Started

The HTTP sessions in _catacumba_ are also implemented as chain handler. So you can
add session handling support to you application just by adding the handler to your
routing chain:

[source, clojure]
----
(require '[catacumba.handlers.session :as session])

(def app
  (ct/routes [[:any (session/session {:storage :inmemory})]
              [:get your-handler]]))
----

All handlers in the route pipeline that are going after the session handler will come
with `:session` key in the context with a "atom" like object. You just treat it
as atom, so for attaching some data to the session you should use the well
known `swap!` function:

[source, clojure]
----
(defn my-handler
  [context]
  (let [session (:session context)]
    (swap! session assoc :userid 1)
    "my response"))
----

You can clean the session just reseting to the empty map:

[source, clojure]
----
(reset! session {})
----

One of the big advantages of using the routing chain for session set up, is that
you can restrict session handling to a concrete subset of urls/resources avoiding
unnecessary code execution for handlers that do not need sessions:

[source, clojure]
----
(def app
  (ct/routes [[:prefix "admin"
               [:any (session/session {:storage :inmemory})]
               [:get your-handler]]
              [:prefix "api"
               [:get "users" other-handler]
               [:get ...]]]))
----


==== Session storages

Currently _catacumba_ comes with one basic session storage, the `:inmemory`. But the
session storage system is pluggable and is defined in terms of the following
protocol:

[source, clojure]
----
(defprotocol ISessionStorage
  (read-session [_ key])
  (write-session [_ key data])
  (delete-session [_ key]))
----

If you are familiar with the ring based session storages, you can observe that the
_catacumba_ session storage abstraction is almost identical to the ring session
abstraction, so migrating from or adapting the ring session storages is really
easy. The unique difference is that functions should return a promise (from
promesa library).

To use a concrete session storage, just pass a instance of it as value of
the `:storage` key in a session handler constructor:

[source, clojure]
----
(session/session {:storage (my-storage-constructor)})
----

If you want implement own session storage, take a look to the `:inmemory` builtin
one.


=== Authentication

_Catacumba_ also comes with authentication facilities heavily inspired by
*buddy-auth*.

We do not have used directly *buddy-auth* because it is designed for ring based
applications, therefore the buddy-auth abstractions are blocking, and blocking api
is not well suited for async based applications.

So, _catacumba_ defines own abstractions for handle authentication, that are very
very similar to the _buddy-auth_, with the exception that them expose asynchronous
api, so adapt existing _buddy-auth_ backends should be very easy.

Like *buddy-auth*, _catacumba_ comes with a little set of builtin backends that can
be used directly: *session*, *jws* (token) and *jwe* (encrypted token).


==== Session

Let start with session authentication backend. This backend is mainly used for web
based applications and consists in verify some value on the session. So this is the
easiest authentication scheme and fits perfectly for the first contact.

Start importing some needed namespaces and create an instance
of the authentication backend:

[source, clojure]
----
(require '[catacumba.http :as http])
(require '[catacumba.handlers.auth :as cauth])

(def auth-backend
  (cauth/session-backend))
----

Now, continue defining a handler for the login action. It consists in receive
credentials from the user input and verify them. In case of success verification,
we just need setup the `:identity` key in the session.

Let see a partially implemented example:

[source, clojure]
----
(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation omitted)
                        (:password data))]
    (swap! (:session context) assoc :identity user)
    (http/ok "ok")))
----

In order to start using auth facilities in your application, you should add the
authentication handler to the routing chain:

[source, clojure]
----
;; The application routes definition with session, auth and body
;; parsing chain handlers

(def app
  (ct/routes [[:any (session/session {:storage :inmemory})] ;; Http Session
              [:any (cauth/auth auth-backend)]              ;; Auth backend
              [:any (parse/body-params)]                  ;; Body parsing
              [:get "login" login-handler]
              [:get some-handler]]))                     ;; (implementation omitted)
----

You can see a working example using auth facilities <<website-example,here>>.


==== JWS Token

This authentication backend consists in use self contained tokens for authenticate
the user. It behaves very similar to the session one but instead of strong the user
information in a server storage, it stores it directly in a token, enabling so,
completely stateless authentication.

NOTE: The security and the implementation of cryptographic primitives for that
token is relied to the *buddy-sign* library (an other module of buddy) that
implements the JWS specification. That library should be used for generate JWS
tokens.

Let start creating a backend instance:

[source, clojure]
----
(def secret "mysecret")
(def auth-backend
  (cauth/jws-backend {:secret secret}))
----

Following of our new login handler:

[source, clojure]
----
(require '[buddy.sign.jws :as jws])
(require '[cheshire.core :as json])

(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation omitted)
                        (:password data))]
    (-> (json/encode {:token (jws/sign {:user (:id user)} secret)})
        (http/ok {:content-type "application/json"}))))
----

And finally, put the new backend into the routing chain:

[source, clojure]
----
(def app
  (ct/routes [[:any (cauth/auth auth-backend)]     ;; Auth backend
              [:any (parse/body-params)]           ;; Body parsing
              [:get "login" login-handler]
              [:get some-handler]]))               ;; (implementation omitted)
----


WARNING: Take care that using jws for create tokens, the data is serialized using
json + base64 and signed using strong cryptography signatures. That method ensure that
the data can not be manipulated by third party but it not protect it from privacy. If
you need store private data in the token, consider using JWE.


==== JWE Token

This authentication backend consists in using self contained tokens for
authenticate the user. It works identically to the JWS (explained previously) with
the exception that instead of only signing data, it also encrypts the data, so
ensuring the data privacy.

You can create the backend instance so:

[source, clojure]
----
(require '[buddy.sign.jwe :as jwe])
(require '[buddy.core.keys :as keys])

(def pubkey (keys/public-key "pubkey.pem"))
(def privkey (keys/private-key "privkey.pem" "thekeysecret"))

(def auth-backend
  (auth/jwe-backend privkey))
----

NOTE: In this example we use asymmetric encryption scheme, if you want use an other
encryption scheme, please check
link:https://funcool.github.io/buddy-sign/latest/#_json_web_encryption[buddy-sign documentation]
for the complete list of supported encryption algorithms.

The login handler is almost identical:

[source, clojure]
----
(require '[buddy.sign.jws :as jws])
(require '[cheshire.core :as json])

(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))]
    (-> (json/encode {:token (jwe/encrypt {:user (:id user)} pubkey)})
        (http/ok {:content-type "application/json"}))))
----

Instead of signing the content, we encrypt it using the public key. The routing
chain is completely identical from the JWE Token examples.


==== Other

If you not happy with the builtin auth facilities, the _catacumba_'s handler system
is very flexible and you really don't need to use _buddy_. You can write your own
auth facilities and attach them to _catacumba_ using the routing chain.


=== Security

==== Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a mechanism that allows restricted
resources (e.g. fonts, JavaScript, etc.) on a web page to be requested from another
domain outside the domain from which the resource originated.

Is often used for allowing API resources to be accessed in a web browser, out of the
domain of your web applications.

_Catacumba_ has builtin support for CORS, and this is how you can use it:

[source, clojure]
----
(require '[catacumba.handlers.misc :as misc])

(def cors-conf {:origin #{"http://website.com"}                     ;; mandatory
                :max-age 3600                                       ;; optional
                :allow-methods #{:post :put :get :delete}           ;; optional
                :allow-headers #{:x-requested-with :content-type}}) ;; optional

(def app
  (ct/routes [[:prefix "api/v1"
               [:any (misc/cors cors-conf)]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----

The `:origin` key can be a set of possible origins or simply `"*"` to allow all
origins.


==== Content Security Policy

Is a security related chain handler that appropriately sets the
`Content-Security-Policy` headers.

Content Security Policy (CSP) is an added layer of security that helps to detect and
mitigate certain types of attacks, including Cross Site Scripting (XSS) and data
injection attacks. These attacks are used for everything from data theft to site
defacement or distribution of malware.

Here a simple example on how to use it:

[source, clojure]
----
(def cspconf {:default-src "'self' *.trusted.com"
              :img-src "*"
              :frame-ancestors "'none'"
              :reflected-xss "filter"})

(def app
  (ct/routes [[:prefix "web"
               [:any (csp-headers cspconf)]
               [:get your-handler]]])
----

You can read more about that here:
https://developer.mozilla.org/en-US/docs/Web/Security/CSP. The complete list of
directives can be found here:
https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives

This handler supports the following directives: `:default-src`, `:frame-ancestors`,
`:frame-src`, `:child-src`, `:connect-src`, `:font-src`, `:form-action`, `:img-src`,
`:media-src`,  `:object-src`, and `:reflected-xss`.


==== Frame Options

This is a security related chain handler that adds `X-Frame-Options` header to the
response.

The X-Frame-Options HTTP response header can be used to indicate whether or not a
browser should be allowed to render a page in a `<frame>`, `<iframe>` or
`<object>` . Sites can use this to avoid clickjacking attacks, by ensuring that
their content is not embedded into other sites.

Example:

[source, clojure]
----
(require '[catacumba.handlers.security :as sec])

(def app
  (ct/routes [[:prefix "web"
               [:any (sec/frame-options-headers {:policy :deny})]
               [:get your-handler]]]))
----

The possible values for the `:policy` key are: `:deny` and `:sameorigin`.

WARNING: The frame-ancestors directive from the CSP Level 2 specification officially
replaces this non-standard header.


==== Strict Transport Security

This is a security related chain handler that adds the `Strict-Transport-Security`
header to the response.

HTTP Strict Transport Security (often abbreviated as HSTS) is a security feature that
lets a web site tell browsers that it should only be communicated with using HTTPS,
instead of using HTTP.

Usage example:

[source, clojure]
----
(require '[catacumba.handlers.security :as sec])

(def app
  (ct/routes [[:prefix "web"
               [:any (sec/hsts-headers {:max-age 31536000 :subdomains true })]
               [:get your-handler]]]))
----

You can read more about that header here:
https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security


==== Content Type Options

This is a security related chain handler that adds the `X-Content-Type-Options`
header to the response. It prevents resources with invalid media types being loaded
as stylesheets or scripts.

This chain handler does not have any additional parameters. Let see an example on
how you can use it:

[source, clojure]
----
(require '[catacumba.handlers.security :as sec])

(def app
  (ct/routes [[:prefix "web"
               [:any sec/content-type-options-headers]
               [:get your-handler]]]))
----


More information:

* http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx
* https://www.owasp.org/index.php/List_of_useful_HTTP_headers


==== CSRF (Cross-Site Request Forgery)

This is a security related chain handler that protects the following handlers from
one-click attack.

For use it, just add it to your routing pipeline:

[source, clojure]
----
(require '[catacumba.handlers.security :as sec])

(def app
  (ct/routes [[:prefix "web"
               [:any (sec/csrf-protect)]
               [:get your-handler]]]))
----

The response will be populated automatically with `csrftoken` cookie that
should be read by the client side javascript and put the same value under
the `x-csrftoken` header or under `csrftoken` form encoded field.

If you want access to the current value of the csrftoken inside catacumba
handler, you can do it using `:catacumba.handlers.security` keyword lookup
on the context.

More information:

* https://en.wikipedia.org/wiki/Cross-site_request_forgery
* https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)


=== Postal

The typical web application usually follows the api REST architecture, but the main
problem of that is that is bound directly to the HTTP semantics that are not
always coherent or not always clear how to use.

This is a backend side implementation
link:https://funcool.github.io/catacumba/latest/postal.html[postal protocol],
that allows expose rich apis based on the user needs on top of http/websockets.

The general idea behind the protocol and this library is borrowed from
link:https://facebook.github.io/relay/[Facebook Relay] and
link:http://netflix.github.io/falcor/[Netflix's Falcor].
The main differents with them is that this library only represents the transport and
message routing layer layer, so it's is nonobstructive and not coupled with
concrete framework and persistence.

One of the great examples where this library fits in a perfection is a
transport and message routing layer for
link:https://github.com/omcljs/om/wiki/Quick-Start-(om.next)[Om.Next]
but it not tied by it.


==== Getting Started

The *postal* handler looks like a default _catacumba_ handler with one extra
argument: frame. The frame is a structured message received from the client that
has this aspect:

[source, clojure]
----
{:type :query
 :dest :users
 :data {:id 1}}
----

NOTE: The `:type` and `:dest` keys are mandatory to be present in the frame.

The messages are by default serialized using transit+json serialization format
but the system is open to be extended with other formats. The serialization is
completely transparent to the user, the catacumba will do all the hard work for
you.

Knowing the frame structure, the best way to define a postal handler is using
multimethods, because they allow easy dispatch by value:

[source, clojure]
----
(require '[catacumba.handlers.postal :as pc])

(defmulti myhandler
  (comp (juxt :type :dest) second vector))

(defmethod myhandler [:query :users]
  [context {:keys [data] :as frame}]
  (let [id (:id data)
        user (repo/get-user-by-id id)]
    (pc/frame user)))

(defmethod myhandler [:novelty :users]
  [context frame]
  (let [status (create-new-user frame)]
    (pc/frame user)))
----

The `message` function is just a helper for create response hashmaps:

[source, clojure]
----
(pc/frame {:foo 1})
;; => {:type :response :data {:foo 1}}
----

In addition to plain return values, you can freely return a promise or deferred
(from *promesa* and *manifold* libraries respectively). And if that abstractions
do not satisfies you, the system is completely open to be extended with your
own abstractions.

And finally, attach the handler on the router:

[source, clojure]
----
(def app
  (ct/routes [[:any "api" (pc/router myhandler)]]))

(ct/run-server #'app)
----


==== Server Push

Additionally to the traditional rpc, it also offers a server-push or/and
bi-directional communication with server.

This is the aspect of the handler that starts the bi-directional communication
with the client:

[source, clojure]
----
(require '[clojure.core.async :as a])

(defn now
  []
  (System/currentTimeMillis))

(defmethod myhandler [:subscribe :timeupdate]
  [context frame]
  (letfn [(on-connect [{:keys [in out] :as context}]
            (a/go-loop []
              (when-let [_ (a/>! out (pc/response :message {:time (now)}))]
                (a/<! (a/timeout 100))
                 (recur))))]
    (pc/socket context on-connect))
----

Behind the scenes, the `socket` function just upgrades to websockets and uses
it as low-level transport layer for message communication between the client and
the server.

Additionally, behind the scenes, catacumba sends a ping frames to the client for
keep alive the connection. This is happens every 5 seconds. At this moment
this value it is not configurable but it will change in a future.

[NOTE]
====
This documentation will explain only the backend related stuff. For client usage,
please refer to the link:https://github.com/funcool/postal[client documentation].
====


=== Request logging

*catacumba* by default does not logs almost anything in console, and the request
logging is not an exception. This is a good default and is very recommended use
reverse proxy logging facilities.

But, if you want request logging in *catacumba*, you can easy activate it just
attaching additional handler to your routing chain:

[source, clojure]
----
(require '[catacumba.handlers.misc :as misc])

(def app
  (ct/routes [[:any (misc/log)]
              ;; here your handlers
              ]))
----

The default implementation in most cases is more than enough, but if you don't happy
with it you can provide your own function for logging:

[source, clojure]
----
(defn my-logging-handler
  [context, outcome]
  (println context outcome))

(def app
  (ct/routes [[:any (misc/log my-logging-handler)]
              ;; here your handlers
              ]))
----

The `context` parameter is just a context that you have already used previously,
and `outcome` is hash map that contains additional data such as: response headers, respose status and request duration time.


=== Instrumentation

TODO



[[plugins]]
== Plugins

This section will explain useful modules that are not part of the core of
_catacumba_ but are fully supported.


[[catacumba-prone]]
=== catacumba-prone

link:https://github.com/magnars/prone[Prone] is a exception reporting middleware for
ring based applications that show a beautiful, navigable and human readable
stacktraces when an exception is throwed in your application.

Full documentation: https://github.com/funcool/catacumba-prone

[NOTE]
====
You can found a <<prone-example,complete example>> using prone in the <<examples,examples section>>.
====


[[examples]]
== Examples

[[website-example]]
=== Website and Auth

This example tries to show the way to use _catacumba_ in a website like projects,
with *authentication* and *sessions*.

Just run the following commands:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/
$ lein with-profile website-example run
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/website[here].


[[websocket-echo-example]]
=== WebSocket Echo

This example application tries to show a very simple application
using the websockets capabilities of _catacumba_

Get it up and running following this commands:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/
$ lein with-profile websocket-echo-example run
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/websocket-echo[here].


[[sse-component-example]]
=== Multiuser chat with SSE

This example tries to demonstrate how can you build a simple chat using
"Server-Sent Events" for communicating events to the client and using
*stuartsierra/component* for a modular application architecture.

For make this example application run, follow this commands:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/
$ lein with-profile component-chat-example run
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

Now, open http://localhost:5050 in two different browsers and try send messages
between them.

You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/component-chat[here].


[[prone-example]]
=== Debugging with prone

link:https://github.com/magnars/prone[Prone] is really awesome middleware for
ring that shows a beautiful and human readable stack traces when a exception is
raised in your application.

Just follow the following commands for get it up and running:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/
$ lein with-profile debugging-example run
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/debugging[here].


NOTE: Obviously, if you are using the ring type of handler, you can use Prone as is,
without any additional adaptation. This example shows how it can be used with
_catacumba_'s default handler type.


=== Instrumentation

_Catacumba_ comes with the ability to instrument your application for taking
different kinds of diagnosis, such as performance, latency, etc. This example
shows how it can be done.

In case of this concrete example application, it uses the instrumentation facilities
of catacumba for monitoring the time of execution of request handlers.

Follow this steps for get this example up and running:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/
$ lein with-profile interceptor-example run
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

And go to http://localhost:5050/

After some requests, you will see the similar output in the console:

```bash
Computation :compute elapsed in: 0.025150461 (sec)
Computation :compute elapsed in: 0.001690894 (sec)
Computation :compute elapsed in: 0.001541675 (sec)
Computation :compute elapsed in: 0.001554894 (sec)
Computation :compute elapsed in: 0.00175033 (sec)
```


You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/interceptor[here].


[[single-file-example]]
=== Single file web app

*This example application requires that you should have
link:http://boot-clj.com[boot-clj] properly installed on your system.*

This example tries to show how you can use _catacumba_ for building small web
applications that fits in one file and execute them like a shell script or
an executable.

You should execute the following commands for get it up and running:

```bash
$ git clone git@github.com:funcool/catacumba.git
$ cd catacumba/examples/single-file
$ export BOOT_CLOJURE_VERSION=1.7.0
$ ./main.clj
[main] INFO ratpack.server.RatpackServer - Ratpack started for http://localhost:5050
```

You can found the source code of this example
link:https://github.com/funcool/catacumba/tree/master/examples/single-file[here].


== FAQ

[[difference-with-aleph]]
=== What is the difference between _catacumba_ and Aleph?

First of all, Aleph is not a real alternative to catacumba, because its approach is
so much low level and its web server support is a little bit constrained by ring
spec.
Furthermore, aleph is already used in catacumba as http client in tests code and
manifold (async abstractions behind aleph) is a first class abstractions
for handle async values.

So, I'm happy to tell you that you can use the both libraries together because
they are very complementary.


[[rationale]]
=== What is the rationale behind this project?

I started writing this library as a research project to provide a simple, non
obstructive (a la ring) without the constraints of the existing ring spec.
The aim is to create a web toolkit for building asynchronous web services.

Here is an incomplete list of things that _catacumba_ aims to achieve:

* Allow different types of handlers by being flexible and extensible
* Provide a simple and lightweight approach for defining asynchronous web services
  with support for different abstractions such as promises, futures, core.async,
  manifold, reactive-streams, etc...
* Build upon abstractions with simplicity and extensibility in mind.
* Provide built in declarative style routing.
* Remain unopinionated and versatile.
* Come with back pressure support out of the box.

_catacumba_ is not designed:

* To be a fully integrated full stack solution like Immutant or Pedestal.
* To provide an opinionated way to structure your "business logic"
* To provide all possible features that you might need.
* To be a low level, ring based library.

The result of this research project is a powerful, lightweight, and fully
extensible asynchronous web toolkit built on top of existing and well designed
components such as Ratpack and Netty.


== Developers Guide

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _catacumba_ should keep these important rules in mind.


=== Contributing

Unlike Clojure and other Clojure contributed libraries _catacumba_ does not have many
restrictions for contributions. Just open an issue or pull request.


=== Source Code

_catacumba_ is open source and can be found on
link:https://github.com/funcool/catacumba[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/catacumba
----

=== Run tests

For running tests just execute this:

[source, text]
----
lein test
----


=== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015 Andrey Antukh <niwi@niwi.nz>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
